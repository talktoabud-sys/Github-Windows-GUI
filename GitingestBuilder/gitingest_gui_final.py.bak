#!/usr/bin/env python3
"""
Windows GUI application to digest folders using Gitingest.
PATCHED VERSION - Fixes encoding issues in gitingest library
"""

import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
import threading
from pathlib import Path
import sys
import io


# CRITICAL: Patch the built-in open() function BEFORE importing gitingest
_original_open = open

def patched_open(file, mode='r', buffering=-1, encoding=None, errors=None, 
                 newline=None, closefd=True, opener=None):
    """
    Patched open() that handles encoding issues gracefully.
    Tries multiple encodings before falling back to error handling.
    """
    # If opening in binary mode or encoding is explicitly set, use original
    if 'b' in mode or encoding is not None:
        return _original_open(file, mode, buffering, encoding, errors, 
                             newline, closefd, opener)
    
    # For text mode reading without explicit encoding, try multiple encodings
    if 'r' in mode and encoding is None:
        encodings_to_try = [
            ('utf-8', 'strict'),
            ('utf-8-sig', 'strict'),  # UTF-8 with BOM
            ('cp1252', 'strict'),      # Windows default
            ('latin-1', 'strict'),     # ISO-8859-1
            ('ascii', 'strict'),
            ('utf-8', 'replace'),      # Last resort: replace bad chars
        ]
        
        last_error = None
        for enc, err in encodings_to_try:
            try:
                return _original_open(file, mode, buffering, enc, err,
                                    newline, closefd, opener)
            except (UnicodeDecodeError, LookupError) as e:
                last_error = e
                continue
        
        # If all encodings fail, open with errors='ignore' to skip bad bytes
        try:
            return _original_open(file, mode, buffering, 'utf-8', 'ignore',
                                newline, closefd, opener)
        except Exception:
            # If even that fails, raise the last error
            raise last_error
    
    # For write mode or other cases, use original with safe defaults
    if encoding is None and 'w' in mode:
        encoding = 'utf-8'
    
    return _original_open(file, mode, buffering, encoding, errors,
                         newline, closefd, opener)


# Apply the patch globally
import builtins
builtins.open = patched_open
io.open = patched_open


def run_ingest(folder_path, output_file, status_text, progress_bar, window):
    """Run the ingestion in a separate thread to keep GUI responsive."""
    try:
        # Import AFTER patching open()
        from gitingest import ingest
        
        status_text.insert(tk.END, f"Processing: {folder_path}\n")
        status_text.insert(tk.END, f"Output: {output_file}\n")
        status_text.insert(tk.END, f"Note: Using smart encoding detection\n\n")
        status_text.see(tk.END)
        window.update()
        
        # Run ingestion - the patched open() will handle encoding issues
        summary, tree, content = ingest(
            source=folder_path,
            output=output_file
        )
        
        # Update status
        status_text.insert(tk.END, "="*60 + "\n")
        status_text.insert(tk.END, "SUMMARY\n")
        status_text.insert(tk.END, "="*60 + "\n")
        status_text.insert(tk.END, summary + "\n\n")
        status_text.insert(tk.END, "‚úì Digest completed successfully!\n")
        status_text.insert(tk.END, f"‚úì Saved to: {output_file}\n")
        status_text.see(tk.END)
        
        progress_bar.stop()
        progress_bar['mode'] = 'determinate'
        progress_bar['value'] = 100
        
        messagebox.showinfo("Success", f"Digest created successfully!\n\nSaved to:\n{output_file}")
        
    except Exception as e:
        progress_bar.stop()
        status_text.insert(tk.END, f"\n‚ùå Error: {str(e)}\n")
        status_text.see(tk.END)
        messagebox.showerror("Error", f"Failed to create digest:\n\n{str(e)}")


class DigestApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Gitingest Folder Digester")
        self.root.geometry("700x550")
        self.root.resizable(True, True)
        
        # Variables
        self.folder_path = tk.StringVar()
        self.output_path = tk.StringVar(value="digest.txt")
        
        self.create_widgets()
    
    def create_widgets(self):
        # Title
        title_frame = tk.Frame(self.root, bg="#2c3e50", pady=15)
        title_frame.pack(fill=tk.X)
        
        title_label = tk.Label(
            title_frame,
            text="üìÅ Gitingest Folder Digester",
            font=("Arial", 16, "bold"),
            bg="#2c3e50",
            fg="white"
        )
        title_label.pack()
        
        subtitle_label = tk.Label(
            title_frame,
            text="Convert any folder into a prompt-friendly text digest",
            font=("Arial", 9),
            bg="#2c3e50",
            fg="#ecf0f1"
        )
        subtitle_label.pack()
        
        # Main content frame
        content_frame = tk.Frame(self.root, padx=20, pady=20)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # Folder selection
        folder_frame = tk.LabelFrame(content_frame, text="Select Folder to Digest", padx=10, pady=10)
        folder_frame.pack(fill=tk.X, pady=(0, 10))
        
        folder_entry = tk.Entry(folder_frame, textvariable=self.folder_path, width=50)
        folder_entry.pack(side=tk.LEFT, padx=(0, 5), fill=tk.X, expand=True)
        
        browse_btn = tk.Button(
            folder_frame,
            text="Browse...",
            command=self.browse_folder,
            bg="#3498db",
            fg="white",
            padx=15
        )
        browse_btn.pack(side=tk.LEFT)
        
        # Output file selection
        output_frame = tk.LabelFrame(content_frame, text="Output File", padx=10, pady=10)
        output_frame.pack(fill=tk.X, pady=(0, 10))
        
        output_entry = tk.Entry(output_frame, textvariable=self.output_path, width=50)
        output_entry.pack(side=tk.LEFT, padx=(0, 5), fill=tk.X, expand=True)
        
        save_btn = tk.Button(
            output_frame,
            text="Save As...",
            command=self.browse_output,
            bg="#3498db",
            fg="white",
            padx=15
        )
        save_btn.pack(side=tk.LEFT)
        
        # Process button
        self.process_btn = tk.Button(
            content_frame,
            text="üöÄ Create Digest",
            command=self.process_folder,
            bg="#27ae60",
            fg="white",
            font=("Arial", 12, "bold"),
            padx=20,
            pady=10
        )
        self.process_btn.pack(pady=10)
        
        # Progress bar
        self.progress = ttk.Progressbar(
            content_frame,
            mode='indeterminate',
            length=300
        )
        self.progress.pack(pady=(0, 10))
        
        # Status text area
        status_frame = tk.LabelFrame(content_frame, text="Status", padx=10, pady=10)
        status_frame.pack(fill=tk.BOTH, expand=True)
        
        self.status_text = scrolledtext.ScrolledText(
            status_frame,
            height=10,
            wrap=tk.WORD,
            font=("Consolas", 9)
        )
        self.status_text.pack(fill=tk.BOTH, expand=True)
        self.status_text.insert(tk.END, "Ready to process a folder.\n")
        self.status_text.insert(tk.END, "‚úì Smart encoding detection enabled\n\n")
        self.status_text.insert(tk.END, "Instructions:\n")
        self.status_text.insert(tk.END, "1. Click 'Browse...' to select a folder\n")
        self.status_text.insert(tk.END, "2. Choose output file location (optional)\n")
        self.status_text.insert(tk.END, "3. Click 'Create Digest' to start\n")
    
    def browse_folder(self):
        folder = filedialog.askdirectory(title="Select Folder to Digest")
        if folder:
            self.folder_path.set(folder)
            # Auto-set output path based on folder name
            folder_name = Path(folder).name
            default_output = str(Path(folder).parent / f"{folder_name}_digest.txt")
            self.output_path.set(default_output)
    
    def browse_output(self):
        file = filedialog.asksaveasfilename(
            title="Save Digest As",
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if file:
            self.output_path.set(file)
    
    def process_folder(self):
        folder = self.folder_path.get()
        output = self.output_path.get()
        
        if not folder:
            messagebox.showwarning("No Folder", "Please select a folder to digest.")
            return
        
        if not Path(folder).exists():
            messagebox.showerror("Invalid Folder", "The selected folder does not exist.")
            return
        
        if not output:
            messagebox.showwarning("No Output", "Please specify an output file.")
            return
        
        # Clear status
        self.status_text.delete(1.0, tk.END)
        
        # Start progress bar
        self.progress['mode'] = 'indeterminate'
        self.progress['value'] = 0
        self.progress.start(10)
        
        # Disable button during processing
        self.process_btn.config(state=tk.DISABLED)
        
        # Run in separate thread
        thread = threading.Thread(
            target=lambda: self._process_wrapper(folder, output)
        )
        thread.daemon = True
        thread.start()
    
    def _process_wrapper(self, folder, output):
        """Wrapper to re-enable button after processing."""
        try:
            run_ingest(folder, output, self.status_text, self.progress, self.root)
        finally:
            self.process_btn.config(state=tk.NORMAL)


def main():
    root = tk.Tk()
    app = DigestApp(root)
    root.mainloop()


if __name__ == "__main__":
    main()